library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity tb_decoder_5to32 is
end tb_decoder_5to32;

architecture sim of tb_decoder_5to32 is
  component decoder_5to32
    port(
      i_EN : in std_logic;
      i_A  : in std_logic_vector(4 downto 0);
      o_Y  : out std_logic_vector(31 downto 0)
    );
  end component;

  signal en : std_logic := '0';
  signal a  : std_logic_vector(4 downto 0) := (others => '0');
  signal y  : std_logic_vector(31 downto 0);

begin
  uut: decoder_5to32
    port map(
      i_EN => en,
      i_A  => a,
      o_Y  => y
    );

  stim: process
  begin
    -- enable off: should always be all zeros
    en <= '0';
    a <= "00000";
    wait for 10 ns;

    a <= "11111"; -- change this to try another addr with enable=0
    wait for 10 ns;

    -- enable on: should be one-hot at the index
    en <= '1';

    a <= "00000"; -- expect y(0)=1
    wait for 10 ns;

    a <= "00001"; -- expect y(1)=1
    wait for 10 ns;

    a <= "00010"; -- expect y(2)=1
    wait for 10 ns;

    a <= "11111"; -- expect y(31)=1
    wait for 10 ns;

    -- random-ish one
    a <= "01001"; -- change this to change which bit is hot (here expect y(9)=1)
    wait for 10 ns;

    -- toggle enable while holding address
    en <= '0'; -- should go back to all zeros
    wait for 10 ns;

    en <= '1'; -- should go back to one-hot again
    wait for 10 ns;

    wait;
  end process;

end sim;
