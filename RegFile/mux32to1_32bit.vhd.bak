library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

-- type has to live somewhere "global-ish" for Questa (vhdl-93 vibes)
package mux32_pkg is
  type word32_array_t is array(0 to 31) of std_logic_vector(31 downto 0);
end package;

package body mux32_pkg is
end package body;

use work.mux32_pkg.all;

entity mux32to1_32bit is
  port(
    i_D : in word32_array_t;
    i_S : in std_logic_vector(4 downto 0);
    o_Y : out std_logic_vector(31 downto 0)
  );
end mux32to1_32bit;

architecture rtl of mux32to1_32bit is
begin
  process(i_D, i_S)
  begin
    -- if select has X/U junk, just spit out 0 so sim doesn't explode
    case i_S is
      when "00000" => o_Y <= i_D(0);
      when "00001" => o_Y <= i_D(1);
      when "00010" => o_Y <= i_D(2);
      when "00011" => o_Y <= i_D(3);
      when "00100" => o_Y <= i_D(4);
      when "00101" => o_Y <= i_D(5);
      when "00110" => o_Y <= i_D(6);
      when "00111" => o_Y <= i_D(7);
      when "01000" => o_Y <= i_D(8);
      when "01001" => o_Y <= i_D(9);
      when "01010" => o_Y <= i_D(10);
      when "01011" => o_Y <= i_D(11);
      when "01100" => o_Y <= i_D(12);
      when "01101" => o_Y <= i_D(13);
      when "01110" => o_Y <= i_D(14);
      when "01111" => o_Y <= i_D(15);
      when "10000" => o_Y <= i_D(16);
      when "10001" => o_Y <= i_D(17);
      when "10010" => o_Y <= i_D(18);
      when "10011" => o_Y <= i_D(19);
      when "10100" => o_Y <= i_D(20);
      when "10101" => o_Y <= i_D(21);
      when "10110" => o_Y <= i_D(22);
      when "10111" => o_Y <= i_D(23);
      when "11000" => o_Y <= i_D(24);
      when "11001" => o_Y <= i_D(25);
      when "11010" => o_Y <= i_D(26);
      when "11011" => o_Y <= i_D(27);
      when "11100" => o_Y <= i_D(28);
      when "11101" => o_Y <= i_D(29);
      when "11110" => o_Y <= i_D(30);
      when "11111" => o_Y <= i_D(31);
      when others => o_Y <= (others => '0');
    end case;
  end process;

end rtl;
