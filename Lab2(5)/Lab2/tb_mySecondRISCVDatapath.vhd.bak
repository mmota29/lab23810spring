library IEEE;
use IEEE.std_logic_1164.all;

entity tb_mySecondRISCVDatapath is
end tb_mySecondRISCVDatapath;

architecture sim of tb_mySecondRISCVDatapath is
	component mySecondRISCVDatapath
		generic(AW : natural := 10; DW : natural := 32);
		port(
			i_CLK : in std_logic;
			i_RST : in std_logic;

			i_RegWrite : in std_logic;
			i_ALUSrc   : in std_logic;
			i_nAddSub  : in std_logic;
			i_MemWrite : in std_logic;
			i_MemToReg : in std_logic;

			i_rs1 : in std_logic_vector(4 downto 0);
			i_rs2 : in std_logic_vector(4 downto 0);
			i_rd  : in std_logic_vector(4 downto 0);

			i_imm12 : in std_logic_vector(11 downto 0);

			o_rs1_data : out std_logic_vector(31 downto 0);
			o_rs2_data : out std_logic_vector(31 downto 0);
			o_alu_out  : out std_logic_vector(31 downto 0);
			o_mem_addr : out std_logic_vector(AW-1 downto 0);
			o_mem_we   : out std_logic;
			o_mem_q    : out std_logic_vector(31 downto 0)
		);
	end component;

	signal clk : std_logic := '0';
	signal rst : std_logic := '0';

	signal RegWrite : std_logic := '0';
	signal ALUSrc   : std_logic := '0';
	signal nAddSub  : std_logic := '0';
	signal MemWrite : std_logic := '0';
	signal MemToReg : std_logic := '0';

	signal rs1 : std_logic_vector(4 downto 0) := (others => '0');
	signal rs2 : std_logic_vector(4 downto 0) := (others => '0');
	signal rd  : std_logic_vector(4 downto 0) := (others => '0');

	signal imm12 : std_logic_vector(11 downto 0) := (others => '0');

	-- debug
	signal rs1d : std_logic_vector(31 downto 0);
	signal rs2d : std_logic_vector(31 downto 0);
	signal aluo : std_logic_vector(31 downto 0);
	signal madd : std_logic_vector(9 downto 0);
	signal mwe  : std_logic;
	signal mq   : std_logic_vector(31 downto 0);

	-- procedure that can drive signals (questa/vhdl-93 picky)
	procedure step(
		signal clk_s : in std_logic;

		signal rs1_s : out std_logic_vector(4 downto 0);
		signal rs2_s : out std_logic_vector(4 downto 0);
		signal rd_s  : out std_logic_vector(4 downto 0);
		signal imm_s : out std_logic_vector(11 downto 0);

		signal RegWrite_s : out std_logic;
		signal ALUSrc_s   : out std_logic;
		signal nAddSub_s  : out std_logic;
		signal MemWrite_s : out std_logic;
		signal MemToReg_s : out std_logic;

		rs1v : std_logic_vector(4 downto 0);
		rs2v : std_logic_vector(4 downto 0);
		rdv  : std_logic_vector(4 downto 0);
		immv : std_logic_vector(11 downto 0);

		rwv  : std_logic;
		asv  : std_logic;
		subv : std_logic;
		mwv  : std_logic;
		mtrv : std_logic
	) is
	begin
		-- change inputs on falling edge so rising edge is the ?execute?
		wait until clk_s = '0';

		rs1_s <= rs1v;
		rs2_s <= rs2v;
		rd_s  <= rdv;
		imm_s <= immv;

		RegWrite_s <= rwv;
		ALUSrc_s   <= asv;
		nAddSub_s  <= subv;
		MemWrite_s <= mwv;
		MemToReg_s <= mtrv;

		wait until clk_s = '1';
		wait for 1 ns;
	end procedure;

begin
	uut: mySecondRISCVDatapath
		port map(
			i_CLK => clk,
			i_RST => rst,

			i_RegWrite => RegWrite,
			i_ALUSrc => ALUSrc,
			i_nAddSub => nAddSub,
			i_MemWrite => MemWrite,
			i_MemToReg => MemToReg,

			i_rs1 => rs1,
			i_rs2 => rs2,
			i_rd => rd,
			i_imm12 => imm12,

			o_rs1_data => rs1d,
			o_rs2_data => rs2d,
			o_alu_out => aluo,
			o_mem_addr => madd,
			o_mem_we => mwe,
			o_mem_q => mq
		);

	clk_proc: process
	begin
		while true loop
			clk <= '0'; wait for 5 ns;
			clk <= '1'; wait for 5 ns;
		end loop;
	end process;

	stim: process
	begin
		-- reset (flip if your dffg reset is active-low)
		rst <= '1';
		wait for 12 ns;
		rst <= '0';
		wait for 8 ns;

		-- ========= program =========
		-- addi x25, zero, 0   (x25 = &A base, treat A[0] at mem addr 0)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00000","00000","11001", x"000",  '1','1','0','0','0');

		-- addi x26, zero, 256  (x26 = &B base, byte addr 256 => word addr 64)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00000","00000","11010", x"100",  '1','1','0','0','0');

		-- lw x1, 0(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00001", x"000",  '1','1','0','0','1');

		-- lw x2, 4(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00010", x"004",  '1','1','0','0','1');

		-- add x1, x1, x2
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00001","00010","00001", x"000",  '1','0','0','0','0');

		-- sw x1, 0(x26)  (store data is rs2=x1)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00001","00000", x"000",  '0','1','0','1','0');

		-- lw x2, 8(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00010", x"008",  '1','1','0','0','1');

		-- add x1, x1, x2
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00001","00010","00001", x"000",  '1','0','0','0','0');

		-- sw x1, 4(x26)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00001","00000", x"004",  '0','1','0','1','0');

		-- lw x2, 12(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00010", x"00C",  '1','1','0','0','1');

		-- add x1, x1, x2
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00001","00010","00001", x"000",  '1','0','0','0','0');

		-- sw x1, 8(x26)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00001","00000", x"008",  '0','1','0','1','0');

		-- lw x2, 16(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00010", x"010",  '1','1','0','0','1');

		-- add x1, x1, x2
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00001","00010","00001", x"000",  '1','0','0','0','0');

		-- sw x1, 12(x26)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00001","00000", x"00C",  '0','1','0','1','0');

		-- lw x2, 20(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00010", x"014",  '1','1','0','0','1');

		-- add x1, x1, x2
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00001","00010","00001", x"000",  '1','0','0','0','0');

		-- sw x1, 16(x26)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00001","00000", x"010",  '0','1','0','1','0');

		-- lw x2, 24(x25)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11001","00000","00010", x"018",  '1','1','0','0','1');

		-- add x1, x1, x2   (final x1 should become 6 with your part-5 memory)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00001","00010","00001", x"000",  '1','0','0','0','0');

		-- addi x27, zero, 512  (&B[64] = byte addr 512)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"00000","00000","11011", x"200",  '1','1','0','0','0');

		-- sw x1, -4(x27)  imm=-4 => 0xFFC
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11011","00001","00000", x"FFC",  '0','1','0','1','0');

		-- sw x1, -4(x27) again
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11011","00001","00000", x"FFC",  '0','1','0','1','0');

		-- ========= quick readback so waveforms prove it =========
		-- lw x28, 0(x26)  expect 1
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00000","11100", x"000",  '1','1','0','0','1');

		-- lw x29, 4(x26)  expect -2 (FFFFFFFE)
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11010","00000","11101", x"004",  '1','1','0','0','1');

		-- lw x30, -4(x27) expect 6
		step(clk, rs1, rs2, rd, imm12, RegWrite, ALUSrc, nAddSub, MemWrite, MemToReg,
			"11011","00000","11110", x"FFC",  '1','1','0','0','1');

		wait;
	end process;

end sim;