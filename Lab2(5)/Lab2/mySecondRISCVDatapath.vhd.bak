library IEEE;
use IEEE.std_logic_1164.all;

entity mySecondRISCVDatapath is
	generic(
		AW : natural := 10;
		DW : natural := 32
	);
	port(
		i_CLK : in std_logic;
		i_RST : in std_logic;

		i_RegWrite : in std_logic;
		i_ALUSrc   : in std_logic;
		i_nAddSub  : in std_logic;
		i_MemWrite : in std_logic;
		i_MemToReg : in std_logic;

		i_rs1 : in std_logic_vector(4 downto 0);
		i_rs2 : in std_logic_vector(4 downto 0);
		i_rd  : in std_logic_vector(4 downto 0);

		i_imm12 : in std_logic_vector(11 downto 0);

		o_rs1_data : out std_logic_vector(31 downto 0);
		o_rs2_data : out std_logic_vector(31 downto 0);
		o_alu_out  : out std_logic_vector(31 downto 0);
		o_mem_addr : out std_logic_vector(AW-1 downto 0);
		o_mem_we   : out std_logic;
		o_mem_q    : out std_logic_vector(31 downto 0)
	);
end mySecondRISCVDatapath;

architecture structural of mySecondRISCVDatapath is
	signal rs1_data : std_logic_vector(31 downto 0);
	signal rs2_data : std_logic_vector(31 downto 0);

	signal imm32    : std_logic_vector(31 downto 0);

	signal alu_b    : std_logic_vector(31 downto 0);
	signal b_inv    : std_logic_vector(31 downto 0);
	signal b_sel    : std_logic_vector(31 downto 0);
	signal alu_out  : std_logic_vector(31 downto 0);
	signal alu_cout : std_logic;

	signal mem_addr : std_logic_vector(AW-1 downto 0);
	signal mem_q    : std_logic_vector(31 downto 0);

	signal wb_data  : std_logic_vector(31 downto 0);

begin
	----------------------------------------------------------------
	-- Register file
	----------------------------------------------------------------
	rf: entity work.regfile_rv32
		port map(
			i_CLK      => i_CLK,
			i_RST      => i_RST,
			i_WE       => i_RegWrite,
			i_rs1      => i_rs1,
			i_rs2      => i_rs2,
			i_rd       => i_rd,
			i_wdata    => wb_data,
			o_rs1_data => rs1_data,
			o_rs2_data => rs2_data
		);

	----------------------------------------------------------------
	-- 12-bit sign extender
	----------------------------------------------------------------
	ext: entity work.ext12to32
		port map(
			i_A    => i_imm12,
			i_SEXT => '1',
			o_Y    => imm32
		);

	----------------------------------------------------------------
	-- ALUSrc mux (32-bit) = 32 copies of scalar mux2t1_df
	-- 0 -> rs2_data
	-- 1 -> imm32
	----------------------------------------------------------------
	gen_alu_src_mux: for i in 0 to 31 generate
	begin
		alu_src_mux_bit: entity work.mux2t1_df(dataflow)
			port map(
				i_S  => i_ALUSrc,
				i_D0 => rs2_data(i),
				i_D1 => imm32(i),
				o_O  => alu_b(i)
			);
	end generate;

	----------------------------------------------------------------
	-- ALU add/sub path built structurally
	-- i_nAddSub = 0 -> add  : A + B + 0
	-- i_nAddSub = 1 -> sub  : A + ~B + 1
	----------------------------------------------------------------

	-- invert B
	u_inv: entity work.OnesComp_N
		generic map(
			N => 32
		)
		port map(
			i_A => alu_b,
			o_O => b_inv
		);

	-- choose B or ~B
	gen_bsel_mux: for i in 0 to 31 generate
	begin
		bsel_mux_bit: entity work.mux2t1_df(dataflow)
			port map(
				i_S  => i_nAddSub,
				i_D0 => alu_b(i),
				i_D1 => b_inv(i),
				o_O  => b_sel(i)
			);
	end generate;

	-- ripple-carry adder
	u_add: entity work.adderN_rca
		generic map(
			N => 32
		)
		port map(
			iA    => rs1_data,
			iB    => b_sel,
			iCin  => i_nAddSub,
			oS    => alu_out,
			oCout => alu_cout
		);

	----------------------------------------------------------------
	-- Memory is word-addressed, ALU output is byte address
	----------------------------------------------------------------
	mem_addr <= alu_out(AW+1 downto 2);

	----------------------------------------------------------------
	-- Data memory
	----------------------------------------------------------------
	dmem: entity work.mem
		generic map(
			DATA_WIDTH => DW,
			ADDR_WIDTH => AW
		)
		port map(
			clk  => i_CLK,
			addr => mem_addr,
			data => rs2_data,
			we   => i_MemWrite,
			q    => mem_q
		);

	----------------------------------------------------------------
	-- MemToReg mux (32-bit) = 32 copies of scalar mux2t1_df
	-- 0 -> alu_out
	-- 1 -> mem_q
	----------------------------------------------------------------
	gen_wb_mux: for i in 0 to 31 generate
	begin
		wb_mux_bit: entity work.mux2t1_df(dataflow)
			port map(
				i_S  => i_MemToReg,
				i_D0 => alu_out(i),
				i_D1 => mem_q(i),
				o_O  => wb_data(i)
			);
	end generate;

	----------------------------------------------------------------
	-- Debug outputs
	----------------------------------------------------------------
	o_rs1_data <= rs1_data;
	o_rs2_data <= rs2_data;
	o_alu_out  <= alu_out;
	o_mem_addr <= mem_addr;
	o_mem_we   <= i_MemWrite;
	o_mem_q    <= mem_q;

end structural;
